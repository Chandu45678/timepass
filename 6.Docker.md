docker-compose.yml in vs code create this file
version: "3.9"

services:
  web:
    image: nginx:latest
    ports:
      - "8080:80"

  db:
    image: postgres:15
    environment:
      POSTGRES_USER: demo
      POSTGRES_PASSWORD: demo
      POSTGRES_DB: demo_db
docker compose up -d 
. Open your browser and visit: http://localhost:8080. 
 Expected Output: 
Nginx welcome page is displayed. 
db container runs in the background. 
 Expected Output: 
Nginx welcome page is displayed. 
db container runs in the background. 
docker compose up -d 
docker compose ps 
 Deploy the same setup across different machines without manual 
configuration. 
I.  Zip your compose-lab folder. 
Transfer it to another machine with Docker Compose installed. 
II. Run: 
docker compose up -d 
Check that Nginx and Postgres work there as well.
 Configure container networking and persistent storage within 
Compose. 
I.  Update your docker-compose.yml to add a custom network and volume: 
networks: 
app-net: 
volumes: 
db-data: 
services: 
web: 
image: nginx:latest 
ports: - "8080:80" 
networks: - app-net 
depends_on: - db 
db: 
image: postgres:15 
environment: 
POSTGRES_USER: demo 
POSTGRES_PASSWORD: demo 
POSTGRES_DB: demo_db 
volumes: - db-data:/var/lib/postgresql/data 
networks: - app-net 
II. Run: 
docker compose up –d 
You already have Postgres running in your docker-compose.yml. 
Now, to insert some data into Postgres, you have two main options: 
*Option 1: Using psql inside the running container* 
1. Start your containers: 
sh 
docker-compose up -d 
2. Open a shell inside the Postgres container: 
sh 
docker exec -it <container_name> psql -U demo -d demo_db 
Replace <container_name> with your Postgres container name (you can check with docker ps). As here 
docker exec -it compose-lab-db-1 psql -U demo -d demo_db 
3. Run SQL commands inside psql: 
sql 
CREATE TABLE users ( 
id SERIAL PRIMARY KEY, 
name VARCHAR(50), 
email VARCHAR(100) 
); 
INSERT INTO users (name, email) VALUES 
('Alice', 'alice@example.com'), 
86 
('Bob', 'bob@example.com'); 
4. Verify data: 
sql 
SELECT * FROM users;
III. Insert some data into Postgres (optional with psql). 
IV. Remove containers: 
docker compose down 
V. Start again: 
docker compose up -d 
VI. Expected Output: 
Database data persists across restarts. 
Services communicate via the app-net network using service names. 
e. Reduce setup time and enable faster iteration during application 
development. 
I.  Create a simple Flask app in app.py: 
from flask import Flask 
app = Flask(__name__) 
@app.route("/") 
def home(): 
return "Hello from Flask + Docker!" 
if __name__ == "__main__": 
app.run(host="0.0.0.0", port=5000) 
II. Add a Dockerfile in the same folder: 
FROM python:3.10-slim 
WORKDIR /app 
COPY app.py /app/ 
RUN pip install flask 
CMD ["python", "app.py"] 
III. Update docker-compose.yml: 
web: 
build: . 
ports: - "5000:5000" 
depends_on: - db 
IV. Run: 
docker compose up --build 
Visit http://localhost:5000. 
Change the return text in app.py (e.g., "Hello Docker Compose!"). 
V. Rebuild: 
docker compose up –build // not needed 
VI. Expected Output: 
New message appears instantly after rebuild.